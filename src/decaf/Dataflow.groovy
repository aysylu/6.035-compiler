package decaf

class TransferFunction{
  // Want to enforce: return type of all of the functions implemented
  // should be of Set<'a> where 'a is the type of element in the set
  // that is generated by the analysis.
}

abstract class JoinOperator<T>{
  // T is the type that will be contained in the sets that hold the
  // analysis information.
  //abstract Set<T> joinOp(List<Set<T>>); // <- error
  //abstract Set<T> joinOp(Set<T>); // <- error
  abstract Set<T> joinOp();
}

class Dataflow {
  // Dataflow analysis works as follows:
  // We define a system of dataflow equations in the following manner:
  // \forall blocks \in program:
  //   out_b = trans_b(in_b)
  //   in_b = join_{p \in predecessors(b)}(out_b)
  // ^^^
  // trans and join are the _transfer function_ and _join operation_, respectively.

  // Transfer function:
  // OutState Transfer(LowIrNode, InState) <- receives a LowIrNode upon which to start
  // the analysis and the state (what the dataflow analysis has yielded so far for this
  // portion of the program). The transfer function should analyze the input state and its
  // relationship to the block to produce the output state. This output state should be
  // monotonically increasing in size.

  // Join operation:
  // This computes the input state for any given node. In the example of a reaching definitions
  // analysis, this would be the union of all definitions holding for nodes that have forward
  // edges into the current node.

  TransferFunction transfer
  JoinOperator joinOp
  LowIrBridge lowir
  
  Dataflow(LowIrBridge lowir, TransferFunction transfer, JoinOperator joinOp){
    this.transfer = transfer
    this.joinOp = joinOp
    this.lowir = lowir
  }

  void analyze(){
    println "lowir start: ${this.lowir}"
  }
}